T_ENUM enum
T_ID rb_color
T_OPEN_K {
T_ID RB_BLACK
T_COMMA ,
T_ID RB_RED
T_CLOSE_K }
T_SEMI_COLON ;
T_STRUCT struct
T_ID rb_node
T_OPEN_K {
T_STRUCT struct
T_ID rb_node
T_ASTERISK *
T_ID left
T_COMMA ,
T_ASTERISK *
T_ID right
T_COMMA ,
T_ASTERISK *
T_ID up
T_SEMI_COLON ;
T_LONG long
T_INT int
T_ID INTvalue
T_SEMI_COLON ;
T_ENUM enum
T_ID rb_color
T_ID color
T_SEMI_COLON ;
T_CLOSE_K }
T_SEMI_COLON ;
T_TYPEDEF typedef
T_STRUCT struct
T_ID rb_node
T_ID rb_node_t
T_SEMI_COLON ;
T_STRUCT struct
T_ID rb_tree
T_OPEN_K {
T_STRUCT struct
T_ID rb_node
T_ASTERISK *
T_ID root
T_SEMI_COLON ;
T_ID unsigned
T_INT int
T_ID size
T_SEMI_COLON ;
T_CLOSE_K }
T_SEMI_COLON ;
T_TYPEDEF typedef
T_STRUCT struct
T_ID rb_tree
T_ID rb_tree_t
T_SEMI_COLON ;
T_VOID void
T_ID _insert_simple
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID tree
T_COMMA ,
T_ID rb_node_t
T_ASTERISK *
T_ID new_node
T_COMMA ,
T_LONG long
T_INT int
T_ID INTvalue
T_CLOSE_P )
T_OPEN_K {
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_SEMI_COLON ;
T_ID tree
T_MINUS -
T_GREATER >
T_ID size
T_PLUS +
T_PLUS +
T_SEMI_COLON ;
T_ID new_node
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_ID new_node
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_ID new_node
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_ID new_node
T_MINUS -
T_GREATER >
T_ID INTvalue
T_ASSIGN =
T_ID INTvalue
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID tree
T_MINUS -
T_GREATER >
T_ID size
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_OPEN_K {
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_ASSIGN =
T_ID new_node
T_SEMI_COLON ;
T_ID new_node
T_MINUS -
T_GREATER >
T_ID coler
T_ASSIGN =
T_ID RB_BLACK
T_SEMI_COLON ;
T_RETURN return
T_SEMI_COLON ;
T_CLOSE_K }
T_ID new_node
T_MINUS -
T_GREATER >
T_ID color
T_ASSIGN =
T_ID RB_RED
T_SEMI_COLON ;
T_ID node
T_ASSIGN =
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_SEMI_COLON ;
T_WHILE while
T_OPEN_P (
T_ID new_node
T_MINUS -
T_GREATER >
T_ID up
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID node
T_MINUS -
T_GREATER >
T_ID INTvalue
T_GREATER >
T_ID INTvalue
T_CLOSE_P )
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID node
T_MINUS -
T_GREATER >
T_ID left
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_OPEN_K {
T_ID new_node
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID node
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_ID new_node
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_ID node
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID left
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID node
T_MINUS -
T_GREATER >
T_ID right
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_OPEN_K {
T_ID new_node
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID node
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_ID new_node
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_ID node
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID right
T_SEMI_COLON ;
T_CLOSE_K }
T_CLOSE_K }
T_CLOSE_K }
T_VOID void
T_ID _rotate_left
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID tree
T_COMMA ,
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_CLOSE_P )
T_OPEN_K {
T_ID rb_node_t
T_ASTERISK *
T_ID child
T_SEMI_COLON ;
T_ID child
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID right
T_SEMI_COLON ;
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_ID child
T_MINUS -
T_GREATER >
T_ID left
T_SEMI_COLON ;
T_ID child
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_ID node
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ELSE else
T_IF if
T_OPEN_P (
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID left
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ELSE else
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_CLOSE_K }
T_VOID void
T_ID _rotate_right
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID tree
T_COMMA ,
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_CLOSE_P )
T_OPEN_K {
T_ID rb_node_t
T_ASTERISK *
T_ID child
T_SEMI_COLON ;
T_ID child
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID left
T_SEMI_COLON ;
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_ID child
T_MINUS -
T_GREATER >
T_ID right
T_SEMI_COLON ;
T_ID child
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_ID node
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ELSE else
T_IF if
T_OPEN_P (
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID left
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID left
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_ELSE else
T_ID child
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID right
T_ASSIGN =
T_ID child
T_SEMI_COLON ;
T_CLOSE_K }
T_ID rb_node_t
T_ASTERISK *
T_ID _uncle_get
T_OPEN_P (
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_COMMA ,
T_CHAR char
T_ASTERISK *
T_ID right_side
T_CLOSE_P )
T_OPEN_K {
T_ID rb_node_t
T_ASTERISK *
T_ID parent
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_ID rb_node_t
T_ASTERISK *
T_ID grandparent
T_ASSIGN =
T_ID parent
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_ID rb_node_t
T_ASTERISK *
T_ID uncle
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID grandparent
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_RETURN return
T_NUM 0
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID grandparent
T_MINUS -
T_GREATER >
T_ID left
T_EQUAL ==
T_ID parent
T_CLOSE_P )
T_OPEN_K {
T_ID uncle
T_ASSIGN =
T_ID grandparent
T_MINUS -
T_GREATER >
T_ID right
T_SEMI_COLON ;
T_ID right_side
T_ASSIGN =
T_NUM 1
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_OPEN_K {
T_ID uncle
T_ASSIGN =
T_ID grandparent
T_MINUS -
T_GREATER >
T_ID left
T_SEMI_COLON ;
T_ID right_side
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_CLOSE_K }
T_RETURN return
T_ID uncle
T_SEMI_COLON ;
T_CLOSE_K }
T_ENUM enum
T_ID _color_case
T_OPEN_K {
T_ID RB_LEFT_LEFT
T_COMMA ,
T_ID RB_LEFT_RIGHT
T_COMMA ,
T_ID RB_RIGHT_LEFT
T_COMMA ,
T_ID RB_RIGHT_RIGHT
T_COMMA ,
T_ID RB_END
T_COMMA ,
T_CLOSE_K }
T_SEMI_COLON ;
T_VOID void
T_ID _swap_colors
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID node1
T_COMMA ,
T_ID rb_tree_t
T_ASTERISK *
T_ID node2
T_CLOSE_P )
T_OPEN_K {
T_ENUM enum
T_ID tb_color
T_ID color
T_SEMI_COLON ;
T_ID color
T_ASSIGN =
T_ID node1
T_MINUS -
T_GREATER >
T_ID color
T_SEMI_COLON ;
T_ID node1
T_MINUS -
T_GREATER >
T_ID color
T_ASSIGN =
T_ID node2
T_MINUS -
T_GREATER >
T_ID color
T_SEMI_COLON ;
T_ID node2
T_MINUS -
T_GREATER >
T_ID color
T_ASSIGN =
T_ID color
T_SEMI_COLON ;
T_CLOSE_K }
T_VOID void
T_ID _re_color
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID tree
T_COMMA ,
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_CLOSE_P )
T_OPEN_K {
T_ID rb_node_t
T_ASTERISK *
T_ID uncle
T_SEMI_COLON ;
T_ID rb_node_t
T_ASTERISK *
T_ID parent
T_ASSIGN =
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_ID rb_node_t
T_ASTERISK *
T_ID grandparent
T_ASSIGN =
T_ID parent
T_MINUS -
T_GREATER >
T_ID up
T_SEMI_COLON ;
T_INT int
T_ID uncle_right
T_SEMI_COLON ;
T_INT int
T_ID parent_right
T_SEMI_COLON ;
T_ENUM enum
T_ID _color_case
T_ID color_case
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_OPEN_P (
T_ID tree
T_MINUS -
T_GREATER >
T_ID root
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_OR ||
T_OPEN_P (
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID color
T_DIFFERENT !=
T_ID RB_BLACK
T_CLOSE_P )
T_CLOSE_P )
T_RETURN return
T_SEMI_COLON ;
T_ID uncle
T_ASSIGN =
T_ID _uncle_get
T_OPEN_P (
T_ID node
T_AMPERSAND &
T_ID uncle_right
T_CLOSE_P )
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID uncle
T_EQUAL ==
T_NUM 0
T_CLOSE_P )
T_RETURN return
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID uncle
T_MINUS -
T_GREATER >
T_ID color
T_EQUAL ==
T_ID RB_RED
T_CLOSE_P )
T_OPEN_K {
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID color
T_ASSIGN =
T_ID RB_BLACK
T_SEMI_COLON ;
T_ID uncle
T_ASSIGN =
T_ID RB_BLACK
T_SEMI_COLON ;
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID color
T_ASSIGN =
T_ID RB_RED
T_SEMI_COLON ;
T_ID _re_color
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID up
T_CLOSE_P )
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID node
T_MINUS -
T_GREATER >
T_ID up
T_MINUS -
T_GREATER >
T_ID left
T_EQUAL ==
T_ID node
T_CLOSE_P )
T_ID parent_right
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_ELSE else
T_ID parent_right
T_ASSIGN =
T_NUM 1
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID parent_right
T_CLOSE_P )
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID uncle_right
T_CLOSE_P )
T_ID color_case
T_ASSIGN =
T_ID RB_RIGHT_RIGHT
T_SEMI_COLON ;
T_ELSE else
T_ID color_case
T_ASSIGN =
T_ID RB_LEFT_RIGHT
T_SEMI_COLON ;
T_CLOSE_K }
T_ELSE else
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID uncle_right
T_CLOSE_P )
T_ID color_case
T_ASSIGN =
T_ID RB_RIGHT_LEFT
T_SEMI_COLON ;
T_ELSE else
T_ID color_case
T_ASSIGN =
T_ID RB_LEFT_LEFT
T_SEMI_COLON ;
T_CLOSE_K }
T_CLOSE_K }
T_ID do
T_OPEN_K {
T_SWITCH switch
T_OPEN_P (
T_ID color_case
T_CLOSE_P )
T_OPEN_K {
T_CASE case
T_ID RB_LEFT_LEFT
T_COLON :
T_ID _rotate_right
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID grandparent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID _swap_colors
T_OPEN_P (
T_ID grandparent
T_COMMA ,
T_ID parent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID color_case
T_ASSIGN =
T_ID RB_END
T_SEMI_COLON ;
T_BREAK break
T_SEMI_COLON ;
T_CASE case
T_ID RB_LEFT_RIGHT
T_COLON :
T_ID _rotate_left
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID parent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID color_case
T_ASSIGN =
T_ID RB_LEFT_LEFT
T_SEMI_COLON ;
T_BREAK break
T_SEMI_COLON ;
T_CASE case
T_ID RB_RIGHT_RIGHT
T_COLON :
T_ID _rotate_left
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID grandparent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID _swap_colors
T_OPEN_P (
T_ID grandparent
T_COMMA ,
T_ID parent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID color_case
T_ASSIGN =
T_ID RB_END
T_SEMI_COLON ;
T_BREAK break
T_SEMI_COLON ;
T_ID default
T_COLON :
T_ID _rotate_right
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID parent
T_CLOSE_P )
T_SEMI_COLON ;
T_ID color_case
T_ASSIGN =
T_ID RB_RIGHT_RIGHT
T_SEMI_COLON ;
T_BREAK break
T_SEMI_COLON ;
T_CLOSE_K }
T_CLOSE_K }
T_WHILE while
T_OPEN_P (
T_ID color_case
T_DIFFERENT !=
T_ID RB_END
T_CLOSE_P )
T_CLOSE_K }
T_VOID void
T_ID rb_insert
T_OPEN_P (
T_ID rb_tree_t
T_ASTERISK *
T_ID tree
T_COMMA ,
T_ID rb_node_t
T_ASTERISK *
T_ID node
T_COMMA ,
T_LONG long
T_INT int
T_ID INTvalue
T_CLOSE_P )
T_OPEN_K {
T_ID _insert_simple
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID node
T_COMMA ,
T_ID INTvalue
T_CLOSE_P )
T_SEMI_COLON ;
T_ID _re_color
T_OPEN_P (
T_ID tree
T_COMMA ,
T_ID node
T_CLOSE_P )
T_SEMI_COLON ;
T_CLOSE_K }
T_EOF 
lines:208
