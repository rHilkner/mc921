T_FLOAT float
T_ID sqrt
T_OPEN_P (
T_FLOAT float
T_ID a
T_CLOSE_P )
T_OPEN_K {
T_RETURN return
T_NUM 0xdeadBEEF
T_SEMI_COLON ;
T_CLOSE_K }
T_FLOAT float
T_ID delta
T_OPEN_P (
T_FLOAT float
T_ID a
T_COMMA ,
T_FLOAT float
T_ID b
T_COMMA ,
T_FLOAT float
T_ID c
T_CLOSE_P )
T_OPEN_K {
T_RETURN return
T_ID b
T_ASTERISK *
T_ID b
T_MINUS -
T_NUM 4
T_DOT .
T_NUM 0
T_ASTERISK *
T_ID a
T_ASTERISK *
T_ID c
T_SEMI_COLON ;
T_CLOSE_K }
T_FLOAT float
T_ID bhaskara_plus
T_OPEN_P (
T_FLOAT float
T_ID a
T_COMMA ,
T_FLOAT float
T_ID b
T_COMMA ,
T_FLOAT float
T_ID c
T_CLOSE_P )
T_OPEN_K {
T_RETURN return
T_OPEN_P (
T_MINUS -
T_ID b
T_PLUS +
T_ID sqrt
T_OPEN_P (
T_ID a
T_COMMA ,
T_ID b
T_COMMA ,
T_ID c
T_CLOSE_P )
T_CLOSE_P )
T_DIV /
T_OPEN_P (
T_NUM 2
T_ASTERISK *
T_ID a
T_CLOSE_P )
T_SEMI_COLON ;
T_CLOSE_K }
T_FLOAT float
T_ID bhaskara_minus
T_OPEN_P (
T_FLOAT float
T_ID a
T_COMMA ,
T_FLOAT float
T_ID b
T_COMMA ,
T_FLOAT float
T_ID c
T_CLOSE_P )
T_OPEN_K {
T_RETURN return
T_MINUS -
T_ID b
T_PLUS +
T_ID sqrt
T_OPEN_P (
T_ID a
T_COMMA ,
T_ID b
T_COMMA ,
T_ID c
T_CLOSE_P )
T_DIV /
T_OPEN_P (
T_NUM 2
T_DOT .
T_NUM 0
T_ASTERISK *
T_ID a
T_CLOSE_P )
T_SEMI_COLON ;
T_CLOSE_K }
T_VOID void
T_ID swapNext
T_OPEN_P (
T_LONG long
T_LONG long
T_INT int
T_ASTERISK *
T_ID array
T_CLOSE_P )
T_OPEN_K {
T_LONG long
T_LONG long
T_INT int
T_ID next
T_ASSIGN =
T_ID array
T_OPEN_B [
T_NUM 1
T_CLOSE_B ]
T_SEMI_COLON ;
T_ID array
T_OPEN_B [
T_NUM 1
T_CLOSE_B ]
T_ASSIGN =
T_ID array
T_OPEN_B [
T_NUM 0
T_CLOSE_B ]
T_SEMI_COLON ;
T_ID array
T_OPEN_B [
T_NUM 0
T_CLOSE_B ]
T_ASSIGN =
T_ID next
T_SEMI_COLON ;
T_NUM 47
T_DOT .
T_NUM 991
T_CLOSE_K }
T_VOID void
T_ID buble_sort_
T_OPEN_P (
T_LONG long
T_LONG long
T_INT int
T_ASTERISK *
T_ID array
T_COMMA ,
T_ID unsigned
T_INT int
T_ID size
T_CLOSE_P )
T_OPEN_K {
T_FOR for
T_OPEN_P (
T_ID unsigned
T_INT int
T_ID i
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_ID i
T_SMALLER <
T_ID size
T_SEMI_COLON ;
T_ID i
T_ASSIGN =
T_ID i
T_PLUS +
T_NUM 1
T_CLOSE_P )
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ID array
T_OPEN_B [
T_ID i
T_CLOSE_B ]
T_G_OR_E >=
T_ID array
T_OPEN_B [
T_ID i
T_PLUS +
T_NUM 1
T_CLOSE_B ]
T_CLOSE_P )
T_OPEN_K {
T_ID swapNext
T_OPEN_P (
T_AMPERSAND &
T_ID array
T_OPEN_B [
T_ID i
T_CLOSE_B ]
T_CLOSE_P )
T_SEMI_COLON ;
T_IF if
T_OPEN_P (
T_ID i
T_DIFFERENT !=
T_NUM 0
T_CLOSE_P )
T_ID i
T_ASSIGN =
T_ID i
T_MINUS -
T_NUM 2
T_SEMI_COLON ;
T_CLOSE_K }
T_CLOSE_K }
T_CLOSE_K }
T_INT int
T_ID a_counter
T_OPEN_P (
T_CHAR char
T_ASTERISK *
T_ID str
T_CLOSE_P )
T_OPEN_K {
T_INT int
T_ID n
T_ASSIGN =
T_NUM 0
T_SEMI_COLON ;
T_WHILE while
T_OPEN_P (
T_ASTERISK *
T_OPEN_P (
T_ID str
T_PLUS +
T_PLUS +
T_CLOSE_P )
T_DIFFERENT !=
T_NUM '\0'
T_CLOSE_P )
T_OPEN_K {
T_IF if
T_OPEN_P (
T_ASTERISK *
T_ID str
T_EQUAL ==
T_NUM 'a'
T_OR ||
T_ASTERISK *
T_ID str
T_EQUAL ==
T_NUM 'A'
T_CLOSE_P )
T_ID n
T_ASSIGN =
T_ID n
T_PLUS +
T_NUM 'd'
T_MINUS -
T_NUM 'b'
T_CLOSE_K }
T_RETURN return
T_ID n
T_SEMI_COLON ;
T_CLOSE_K }
T_EOF 
lines:35
